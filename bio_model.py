
from params import *
import math
from scipy.integrate import solve_ivp
import numpy as np

# =========================================================================
# Biological / MPC equations
# =========================================================================

def tao(t: float) -> float:
    """Temperature effect τ(T)."""
    k = 4.6
    if t > T_opt:
        return math.exp(-k * ((t - T_opt) / (T_max - T_opt))**4)
    if t < T_opt:
        return math.exp(-k * ((T_opt - t) / (T_opt - T_min))**4)
    return 1.0


def segma(x: float) -> float:
    """Dissolved oxygen limitation function σ(DO)."""
    if x >= DO_crt:
        return 1.0
    if DO_min < x < DO_crt:
        return (x - DO_min) / (DO_crt - DO_min)
    return 0.0


def v(x: float) -> float:
    """Unionized ammonia effect v(UIA)."""
    if x < UIA_crit:
        return 1.0
    if UIA_crit < x < UIA_max:
        return (UIA_max - x) / (UIA_max - UIA_crit)
    return 0.0


def BF_capacity(TAN_prev: float) -> float:
    """Biofilter capacity BF_{t-1}."""
    TAN_prev = max(0.0, TAN_prev)

    return n_BF * (TAN_prev ** k_BF)

'''
def update_TAN(TAN_prev: float, feed_kg: float) -> float:
    """Update TAN based on previous TAN and feed amount (kg).
    production of TAN P77"""

    TAN_current = ((feed_kg * PC * 0.094) * 1000) / V_water  + max(0,TAN_prev)      # total ammonia produced as a result of food in [mg/L]

    r_N_capacity = ((n_BF * (TAN_current ** k_BF)) * V_BF) * 1000 / V_water            # conversion rate multiplyed by biofilter volume devided by tank volume
    r_N_actual = min(r_N_capacity, TAN_current)

    TAN_next = TAN_current - r_N_actual                                             # TAN remained is 
    return max(TAN_next,0)                                                          # returns the current value of TAN

    input_term   = (1.0 - NPU) * (PC / 6.25) * feed_kg
    BF_prev      = BF_capacity(TAN_prev)
    removal_term = (BF_prev * V_BF) / V_water

    TAN_next = TAN_prev + input_term - removal_term
    return TAN_next
'''


def update_water_quality(TAN_prev: float, NO3_prev: float, feed_kg: float) -> tuple:
    """
    Update TAN and Nitrate based on feed and biofilter performance.
    Returns: (TAN_next, NO3_next)
    """

    TAN_pool = ((feed_kg * PC * 0.094) * 1000) / V_water + max(0.0, TAN_prev)

    # Removal Capacity
    r_N_capacity = ((n_BF * (TAN_pool ** k_BF)) * V_BF) * 1000 / V_water
    
    # Actual Removal
    r_N_actual = min(r_N_capacity, TAN_pool)


    TAN_next = max(TAN_pool - r_N_actual, 0.0)
    
    # Update Nitrate
    NO3_next = max(0.0, NO3_prev) + r_N_actual
    
    return TAN_next, NO3_next


def TAN_to_UIA(TAN: float) -> float:
    """
    Compute UIA (unionized ammonia) from TAN using pH and pKa:
        UIA = TAN / (1 + 10^(pKa - pH))
    Based on M. Saadi's code.
    """
    UIA = TAN / (1 + 10**(PK_a - PH))
    return max(UIA, 0.0)
    

def dwdt(t: float, w: float, UIA: float, f: float, T: float, DO: float) -> float:
    """
    Main growth ODE: dw/dt as a function of weight, UIA and feed ratio.
    f is feeding ratio (fraction of body weight per day).
    """
    growth = h * p * f * b * (1 - a) * tao(T) * segma(DO) * v(UIA) * w**m
    loss   = k_min * math.exp(j * (T - T_min)) * w**n
    return growth - loss


def run_sim(ind, initial_weight, initial_Tan, initial_Nitrate=0.0):
    
    feeds      = [float(t[0]) for t in ind]    # from the individual generated by the GA, the first is the feed
    temps      = [float(t[1]) for t in ind]
    DOs        = [float(t[2]) for t in ind]
    
    t_span = (0.0, 1.0)  # integrate over 1 day

    weights  = [initial_weight]
    tan_lst  = [initial_Tan]
    no3_lst  = [initial_Nitrate]
    feeds_kg = []
    
    for day in range(len(ind)):

        w_tmp          = weights[-1]
        tan_tmp        = tan_lst[-1]
        no3_tmp        = no3_lst[-1]

        UIA_current = TAN_to_UIA(tan_tmp)

        current_feed = feeds[day]
        current_temp = temps[day]
        current_DO = DOs[day]
        
        sol = solve_ivp(
            lambda t, w: dwdt(t, w, UIA_current, current_feed, current_temp, current_DO),
            t_span,
            [w_tmp],
            t_eval=[t_span[1]]
        )

        if not sol.success:
            raise RuntimeError(f"ODE failed on day {day}: {sol.message}")

        w_tmp = sol.y[0, -1]
        weights.append(w_tmp)

        # Update TAN, feed and nitrate
        feed_kg = current_feed * w_tmp
        tan_tmp, no3_tmp= update_water_quality(tan_tmp, no3_tmp, feed_kg)
        tan_lst.append(tan_tmp)
        no3_lst.append(no3_tmp)
        feeds_kg.append(feed_kg)

    return weights, feeds_kg, tan_lst, no3_lst, temps, DOs


def profit(w_final: float,
           w_initial: float,
           f_list,
           T_list,
           DO_list,
           days) -> float:
    """
    Bio-economic profit for a given period.

    :param w_final:  final fish weight (kg)
    :param w_initial: initial fish weight (kg)
    :param f_list:   list of feed amounts in kg over the period
    :param T:        water temperature (°C)
    :param DO:       dissolved oxygen (mg/L)
    :param days:     number of days in this profit period
    """

    assert len(f_list) == len(T_list) == len(DO_list) == days

    # ================= Revenue =================
    revenue = (w_final - w_initial) * p_fish

    # ================= Feed cost =================
    total_feed = 0
    
    for f in f_list:
        total_feed += f

    feed_cost = total_feed * p_feed

   # ================= Electricity costs =================
    heat_cost = 0.0
    DO_cost   = 0.0

    for T, DO in zip(T_list, DO_list):
        T = float(np.asarray(T).squeeze())
        DO = float(np.asarray(DO).squeeze())

        heat_flux = area * 12.12 * max(0.0, T - T_env) / N_fish
        heat_cost += (heat_flux / 1000.0) * electricity_price * 24.0

        DO_extra = max(0.0, DO - DO_base)
        DO_cost += ((DO_extra / 1000.0 / 24) / 0.46) * electricity_price * 24.0

    electricity_cost = (heat_cost + DO_cost) / N_fish # for now we divide by 100 to make this system for one fish

    # ================= Total cost =================
    total_cost = feed_cost + electricity_cost

    return revenue - total_cost
#========================================================================================