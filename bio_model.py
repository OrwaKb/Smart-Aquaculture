
from params import *
import math
from scipy.integrate import solve_ivp
import numpy as np

# =========================================================================
# Biological / MPC equations
# =========================================================================

def tao(t: float) -> float:
    """Temperature effect τ(T)."""
    k = 4.6
    if t > T_opt:
        return math.exp(-k * ((t - T_opt) / (T_max - T_opt))**4)
    if t < T_opt:
        return math.exp(-k * ((T_opt - t) / (T_opt - T_min))**4)
    return 1.0


def segma(x: float) -> float:
    """Dissolved oxygen limitation function σ(DO)."""
    if x >= DO_crt:
        return 1.0
    if DO_min < x < DO_crt:
        return (x - DO_min) / (DO_crt - DO_min)
    return 0.0


def v(x: float) -> float:
    """Unionized ammonia effect v(UIA)."""
    if x < UIA_crit:
        return 1.0
    if UIA_crit < x < UIA_max:
        return (UIA_max - x) / (UIA_max - UIA_crit)
    return 0.0


def BF_capacity(TAN_prev: float) -> float:
    """Biofilter capacity BF_{t-1}."""
    return n_BF * (TAN_prev ** k_BF)


def update_TAN(TAN_prev: float, feed_kg: float) -> float:
    """Update TAN based on previous TAN and feed amount (kg)."""
    feed_g = feed_kg * 1000.0  # convert to grams

    input_term   = (Nf * feed_g) / V_water
    BF_prev      = BF_capacity(TAN_prev)
    removal_term = (BF_prev * V_BF) / V_water

    TAN_next = TAN_prev + input_term - removal_term
    return max(TAN_next, 0.0)


def TAN_to_UIA(TAN: float) -> float:
    """
    Compute UIA (unionized ammonia) from TAN using pH and pKa:
        UIA = TAN / (1 + 10^(pKa - pH))
    Based on M. Saadi's code.
    """
    UIA = TAN / (1 + 10**(PK_a - PH))
    return max(UIA, 0.0)
    #return TAN * frac_UIA


def dwdt(t: float, w: float, UIA: float, f: float, T: float, DO: float) -> float:
    """
    Main growth ODE: dw/dt as a function of weight, UIA and feed ratio.
    f is feeding ratio (fraction of body weight per day).
    """
    growth = h * p * f * b * (1 - a) * tao(T) * segma(DO) * v(UIA) * w**m
    loss   = k_min * math.exp(j * (T - T_min)) * w**n
    return growth - loss


def run_sim(ind, initial_weight, initial_Tan):
    
    feeds      = [float(t[0]) for t in ind]    # from the individual generated by the GA, the first is the feed
    temps      = [float(t[1]) for t in ind]
    DOs        = [float(t[2]) for t in ind]
    
    t_span = (0.0, 1.0)  # integrate over 1 day

    weights = [initial_weight]
    tan_lst    = [initial_Tan]
    feeds_kg = []
    
    for day in range(len(ind)):

        w_tmp          = weights[-1]
        tan_tmp        = tan_lst[-1]

        UIA_current = TAN_to_UIA(tan_tmp)

        current_feed = feeds[day]
        current_temp = temps[day]
        current_DO = DOs[day]
        
        sol = solve_ivp(
            lambda t, w: dwdt(t, w, UIA_current, current_feed, current_temp, current_DO),
            t_span,
            [w_tmp],
            t_eval=[t_span[1]]
        )

        if not sol.success:
            raise RuntimeError(f"ODE failed on day {day}: {sol.message}")

        w_tmp = sol.y[0, -1]
        weights.append(w_tmp)

        # Update TAN and feed
        feed_kg = current_feed * w_tmp
        tan_tmp = update_TAN(tan_tmp, feed_kg)
        tan_lst.append(tan_tmp)
        feeds_kg.append(feed_kg)

    return weights, feeds_kg, tan_lst, temps, DOs


def profit(w_final: float,
           w_initial: float,
           f_list,
           T_list,
           DO_list,
           days) -> float:
    """
    Bio-economic profit for a given period.

    :param w_final:  final fish weight (kg)
    :param w_initial: initial fish weight (kg)
    :param f_list:   list of feed amounts in kg over the period
    :param T:        water temperature (°C)
    :param DO:       dissolved oxygen (mg/L)
    :param days:     number of days in this profit period
    """

    assert len(f_list) == len(T_list) == len(DO_list) == days

    # ================= Revenue =================
    revenue = (w_final - w_initial) * p_fish

    # ================= Feed cost =================
    total_feed = 0
    
    for f in f_list:
        total_feed += f

    feed_cost = total_feed * p_feed

   # ================= Electricity costs =================
    heat_cost = 0.0
    DO_cost   = 0.0

    for T, DO in zip(T_list, DO_list):
        T = float(np.asarray(T).squeeze())
        DO = float(np.asarray(DO).squeeze())

        heat_flux = area * 12.12 * max(0.0, T - T_env)
        heat_cost += (heat_flux / 1000.0) * electricity_price * 24.0

        DO_extra = max(0.0, DO - DO_base)
        DO_cost += ((DO_extra / 1000.0) / 0.46) * electricity_price * 24.0

    electricity_cost = (heat_cost + DO_cost) / N_fish # for now we divide by 100 to make this system for one fish

    # ================= Total cost =================
    total_cost = feed_cost + electricity_cost

    return revenue - total_cost
#========================================================================================